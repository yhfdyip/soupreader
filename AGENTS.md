# SoupReader 协作规范（AGENTS）

> 适用范围：`/home/server/soupreader` 全项目。

## 1) 总原则（强约束）

- 所有回复、说明、代码评审意见默认使用中文。
- **书源处理规则语义与功能行为以同级项目 `legado` 为第一标准**。
- **全仓库默认采用“迁移级别”推进，不采用“最小收敛”作为默认策略**。

### 1.1 legado 复刻前置规则（强制）

- 所有功能开发在动手前，必须先确认 legado 中对应功能的实现与行为。
- 所有功能开发在确认 legado 对应实现时，必须将相关 legado 文件完整读取后再下结论。
- 复刻时必须以 legado 的交互语义、状态流转和边界处理为基准，避免主观改写。
- 若暂时无法确认 legado 对应实现，需先暂停开发并与需求方确认后再继续。
- 未经需求方明确同意，不得将任务口径降级为“最小收敛”或“仅主链路一致”。

### 1.1.1 迁移级别定义（强制）

- 适用范围：全仓库所有模块（业务页面、服务层、工具层）。
- 迁移级别口径：除 UI 风格差异外，以下语义必须与 legado 同义：
  - 交互路径与入口层级
  - 状态流转与边界处理
  - 生命周期与取消/清理行为
  - 错误处理与可观测输出
  - 菜单结构、排序与触发逻辑
  - 用户可见文案的业务语义
- 允许差异：仅限 `Shadcn + Cupertino` 与 Flutter 平台实现差异，不得改变功能语义。
- 禁止事项：不得保留会导致行为偏差的扩展入口、扩展流程、扩展文案。

### 1.1.2 迁移例外流程（强制）

- 若 legado 能力暂无法等价复现，必须先暂停并与需求方确认后再继续。
- 发现例外时，必须先将对应 ExecPlan 状态标记为 `blocked`，禁止继续实现主流程。
- 例外项必须记录在同一份 ExecPlan 文档（`.agent/PLANS.md` 或 `PLANS.md`）中，并至少同步到：
  - `Surprises & Discoveries`（记录例外现象与触发条件）
  - `Decision Log`（记录取舍与确认结论）
  - `Progress`（记录当前阻塞点与下一步）
- 例外记录至少包含：
  - 原因
  - 影响范围
  - 替代方案
  - 回补计划
- 未完成上述确认与记录前，例外项视为阻塞问题，不得宣称已完成一致性迁移。

### 1.2 UI 规范（强制）

- 使用 `Shadcn + Cupertino`。
- 全项目新增/改造 UI 必须使用 `Shadcn + Cupertino` 组合。
- 禁止引入或混用其它 UI 组件体系（如纯 Material 风格组件）作为主实现。
- 若遇到 `Shadcn/Cupertino` 暂无等价能力的特殊场景，必须在任务说明与 ExecPlan 文档中写明原因、范围和替代方案。
- 评审若发现不符合本规范，视为阻塞项，需整改后再提交。
- 文档：`https://mariuti.com/flutter-shadcn-ui/llms.txt`

---

## 2) 功能落地要求（按 legado 目标推进）

### 2.1 网络与会话

- 保持持久化 CookieJar（应用重启后可复用会话）。
- 维持请求/响应编码处理（含 GBK 等站点常见编码回退）。
- 请求层异常必须可观测（状态码、关键响应头、错误摘要）。

### 2.2 五段链路必须可调试

- 搜索（search）
- 发现（explore）
- 详情（bookInfo）
- 目录（toc）
- 正文（content）

任何影响上述链路的改动，必须同步维护调试输出与回归验证。

### 2.3 迁移对照与验收（强制）

- 每个迁移任务在实现前，必须先输出“差异点清单”（含文件位置、原因、影响）。
- 实现完成后，必须输出“逐项对照清单”（标注已同义/保留差异及原因）。
- 验收结果必须包含可复现证据：
  - 命令验证（如 `flutter analyze`、相关测试）
  - 手工回归路径（入口与操作步骤）
- 在逐项对照完成前，不得直接宣称“已经一致”。

---

## 3) 测试与验收（提交推送前检查）

- 在提交推送前，必须执行且仅执行一次：
  - `flutter analyze`
- 开发过程中（实现、对比、迁移、联调阶段）禁止执行 `flutter analyze`。
- 若未进入提交推送阶段，不得提前执行 `flutter analyze`。
- 中途需要校验时，使用与改动相关的定向测试或手工回归路径；完整 `flutter analyze` 保留到提交前。
- 若任务为迁移级别开发，除上述硬性检查外，还必须补充与改动相关的回归验证（自动化测试或手工路径），并写入对应 ExecPlan 文档。

---

## 4) 计划文档更新（必须）

- 每次完成一个可交付点（修复/新增/调整）后，**必须**同步更新：
  - 对应 ExecPlan 文档（`.agent/PLANS.md` 或 `PLANS.md`，也可为 `docs/plans/*.md` 并在主计划中索引）
- 更新内容至少包含：
  - 做了什么（变更点）
  - 为什么（问题/需求）
  - 如何验证（测试命令或手工路径）
- 若改动可能影响旧书源兼容性，必须在进度记录中写清“兼容影响”。

---

## 5) 任务执行与沟通流程（必须）

- 接到需求后，先拆分为可执行的 Todo 列表，并标注每项的依赖关系与可并行性（串行/并行）。
- 若任务属于迁移级别开发，Todo 第 1 项必须是“差异点清单”输出；在该项完成前，不得启动实现类并行分支。
- 在不违反依赖关系的前提下，允许并行推进多个 Todo；存在前置依赖的事项必须按依赖顺序串行执行。
- 并行开发时，每个 Todo 必须明确 owner；同一时段若涉及同一文件/同一逻辑区块，必须先完成分工对齐，避免无序覆盖。
- 并行分支每完成一个可交付点，必须各自同步更新对应 ExecPlan 记录（做了什么、为什么、如何验证、兼容影响）。
- 执行过程中，不要在每完成一项后询问“是否继续”。
- 仅在以下场景可以暂停并询问：
  1. 缺少必要信息，导致无法继续；
  2. 存在明显风险或破坏性操作（如删除、覆盖、付费、生产环境操作等）。
- 并行分支若出现冲突或阻塞，必须先在 ExecPlan 标记状态（`blocked`/风险说明）并记录处理方案，再继续其它可推进分支。
- 若迁移任务尚未完成逐项对照清单，结论中不得使用“完全一致/已一致”等完成态措辞。
- 全部完成后，回复必须包含：
  - 并行分支完成情况汇总（含未完成/阻塞项）
  - 完成情况汇总
  - 变更文件列表
  - 如何验证

---

## 6) ExecPlans 执行计划机制（强制）

> 参考：`https://developers.openai.com/cookbook/articles/codex_exec_plans/`

### 6.0 官方最小触发规则（按 Cookbook 原文语义）

- 默认触发语义按下述规则执行（原文等义）：
  - 当编写复杂功能或重大重构时，应从设计到实现全程使用 ExecPlan。
  - 对应英文原句：`When writing complex features or significant refactors, use an ExecPlan (as described in .agent/PLANS.md) from design to implementation.`
- 本仓库路径约定与上句并行解释如下：
  - 若存在 `.agent/PLANS.md`，优先按该文件约束执行；
  - 若不存在 `.agent/PLANS.md`，则以仓库根 `PLANS.md` 作为等价规范入口。

### 6.1 何时必须使用 ExecPlan

- 对于复杂功能、显著重构、跨模块迁移、或存在明显不确定性的任务，必须先产出 ExecPlan，再进入实现。
- 满足以下任一条件即强制触发：
  - 涉及多个阶段或多个里程碑，无法在一次短上下文中稳定完成；
  - 涉及跨模块/跨层改动（页面、服务、工具层任意两层及以上）；
  - 涉及公共接口、状态流转、数据模型、兼容策略调整；
  - 失败后存在明显回滚成本、用户可见风险或数据风险。
- 低风险、单点、可快速闭环的小改动可不单独建 ExecPlan，但仍需遵守第 4 章进度更新要求。

### 6.2 文档载体与命名

- 仓库根 `PLANS.md` 作为 ExecPlan 规范与索引入口（living document）。
- 具体任务可采用以下任一方式承载：
  - 直接在 `PLANS.md` 中按任务分节维护；
  - 使用 `docs/plans/<YYYY-MM-DD>-<task>-execplan.md` 单任务文件，并在 `PLANS.md` 建立索引链接。
- ExecPlan 必须自包含：不依赖聊天上下文，单独阅读文档即可执行。

### 6.3 ExecPlan 内容结构（必填）

- 每个 ExecPlan 至少包含以下静态章节：
  - 背景与目标（含范围、非目标、成功标准）；
  - 差异点清单（含文件位置、原因、影响）；
  - 实施步骤（按顺序、每步包含预期结果与验证方式）；
  - 风险与回滚（失败模式、阻塞条件、回退策略）；
  - 验收与证据（命令验证、手工路径、预期输出）。
- 每个 ExecPlan 必须包含以下动态章节（执行中持续更新）：
  - `Progress`（当前进度与剩余事项）；
  - `Surprises & Discoveries`（执行中发现与偏差）；
  - `Decision Log`（关键取舍与理由）；
  - `Outcomes & Retrospective`（结果总结与后续改进）。

### 6.4 执行状态与更新要求

- ExecPlan 状态统一使用：`draft`、`active`、`blocked`、`done`。
- 进入实现前必须至少完成 `draft -> active` 的计划落盘记录。
- 每完成一个可交付点，必须同时更新：
  - 对应 ExecPlan（步骤状态、发现、决策、结果）；
  - 对应步骤的实施记录（做了什么、为什么、如何验证、兼容影响）。
- 若执行过程出现计划偏移，必须先更新 ExecPlan 再继续编码；禁止无记录偏航。
- 若出现无法等价复现 legado 的例外，必须同时遵守第 `1.1.2` 章的暂停确认与记录流程。

### 6.5 与现有规范的关系（优先级）

- ExecPlan 是执行过程约束，**补充**而不替代现有硬规则。
- 以下约束继续强制且优先级不变：
  - legado 同义迁移与边界语义一致性；
  - `Shadcn + Cupertino` UI 规范；
  - 第 3 章测试与验收约束（尤其 `flutter analyze` 仅在提交推送前执行一次）；
  - 第 2.2 章“五段链路可调试”与第 2.3 章“逐项对照清单”要求。
